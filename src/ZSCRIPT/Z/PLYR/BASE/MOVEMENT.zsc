extend
class ZPlayer{
    transient
    bool MidAir,
         MidClamber,
         CrouchingJump;

    transient
    int DashOppurt,
        DashCountdown,
        CurrentDashButton;

    transient
    double LedgeHeight;

    transient
    Vector3 LastVel;

    meta
    double MaxLedgeHeight;

    Property MaxLedgeHeight: MaxLedgeHeight;

    Default{
        MaxStepHeight 18;
        ZPlayer.MaxLedgeHeight 35;
    }

    override
    void HandleMovement(){
        let Player=self.Player;
        //[RH] Check for fast turn around
        if((Player.cmd.buttons & ~Player.oldbuttons) & BT_TURN180)
            Player.turnticks=TURN180_TICKS;
        //Handle Movement
        if(ReactionTime)ReactionTime--;
        else{
            MovePlayer();
            CheckMoveUpDown();
            CheckJump();
            CheckClamber();
            HandleArmorMovement();
            //Crouch-jumping and reduce crouch step height
            if(Player.OnGround)MaxStepHeight=(Player.CrouchOffset!=0)?14:18;
            else MaxStepHeight=(Player.CrouchOffset!=0 && !CrouchingJump)*5;
            //Other Checks
            LowerFriction();
        }
    }

    virtual
    void HandleArmorMovement(){}

    override
    void MovePlayer(){
        let Player = self.Player;
        UserCmd cmd = Player.cmd;

        //[RH] 180-degree turn overrides all other yaws
        if (Player.turnticks){
            Player.turnticks--;
            Angle+=(180./TURN180_TICKS);
        }else Angle+=cmd.yaw*(360./65536.);

        Player.OnGround=(Pos.Z<=FloorZ) || bOnMobj || bMBFBouncer || (Player.Cheats & CF_NOCLIP2);

        //killough 10/98:
        //
        //We must apply thrust to the Player and bobbing separately, to avoid
        //anomalies. The thrust applied to bobbing is always the same strength on
        //ice, because the Player still "works just as hard" to Move, while the
        //thrust applied to the Movement varies with 'MoveFactor'.
        if (cmd.forwardMove|cmd.sideMove){
            double MoveFactor,
                   BobFactor,
                   Friction,
                   ForwardMove,
                   SideMove;

            [Friction, MoveFactor]=GetFriction();
            BobFactor=Friction<ORIG_FRICTION?MoveFactor:ORIG_FRICTION_FACTOR;
            if (!Player.OnGround && !bNoGravity && !waterlevel){
                //[RH] allow very limited Movement if not on ground.
                double AirControl=GetAirControl();
                MoveFactor*=AirControl;
                BobFactor*=AirControl;
            }

            ForwardMove=cmd.ForwardMove;
            SideMove=cmd.SideMove;
            [ForwardMove, SideMove]=TweakSpeeds(ForwardMove, SideMove);
            ForwardMove*=Speed/256;
            SideMove*=Speed/256;

            //When crouching, speed and bobbing have to be reduced
            if (CanCrouch() && Player.CrouchFactor!=1){
                ForwardMove*=Player.CrouchFactor;
                SideMove*=Player.CrouchFactor;
                BobFactor*=Player.CrouchFactor;
            }

            ForwardMove*=MoveFactor*(35/TICRATE);
            SideMove*=MoveFactor*(35/TICRATE);

            ForwardMove*=CheckSprint();

            if (ForwardMove){
                Bob(Angle, cmd.ForwardMove * BobFactor / 256., true);
                ForwardThrust(ForwardMove, Angle);
            }
            if (SideMove){
                let a=Angle-90;
                Bob(a, cmd.SideMove*BobFactor/256., false);
                Thrust(SideMove, a);
            }

            if ((~Player.Cheats & CF_PREDICTING) && (ForwardMove!=0 || SideMove!=0))PlayRunning();

            if (Player.Cheats & CF_REVERTPLEASE){
                Player.Cheats &= ~CF_REVERTPLEASE;
                Player.Camera=Player.Mo;
            }
        }
    }

    virtual
    double GetAirControl()
    {return 1;}

    virtual
    double CheckSprint()
    {return 1;}

    override
    void CheckJump(){
        //[RH] check for jump
        if(Buttons & BT_JUMP){
            if(WaterLevel>=2)Vel.Z=4*Speed;
            else if(bNoGravity)Vel.Z=3.;
            else if(Level.IsJumpingAllowed() && Player.OnGround && Player.JumpTics==0){
                double JumpVelZ=JumpZ*35/TICRATE,
                       JumpFac=0;
                CrouchingJump=Player.CrouchOffset!=0;

                //[BC] If the player has the high jump power, double his jump velocity.
                //(actually, pick the best factors from all active items.)
                for (PowerHighJump p=PowerHighJump(Inv); p!=null; p=PowerHighJump(p.Inv))
                    if(p && p.Strength>JumpFac)JumpFac=p.Strength;

                if(JumpFac>0)JumpVelZ*=JumpFac;

                Vel.Z+=JumpVelZ;
                bOnMobj=false;
                Player.JumpTics=-1;
                if(~Player.Cheats & CF_PREDICTING)A_PlaySound("*jump", CHAN_BODY);
            }
        }
    }

    virtual
    void CheckClamber(){
        Vector3 LastPos=Pos;
        SetXYZ(Pos+(0, 0, MaxLedgeHeight));
        LedgeHeight=GetZAt(Radius+4)-LastPos.Z;
        SetXYZ(LastPos);
        bool Jumping=Buttons & BT_JUMP;
        if(!MidClamber){
            MidClamber=Player.JumpTics!=0 && Vel.Z<=0 && LedgeHeight>(Player.CrouchOffset!=0)*MaxStepHeight && LedgeHeight<=MaxLedgeHeight;
        }else{
            if(LedgeHeight>MaxLedgeHeight)MidClamber=false;
            else if(LedgeHeight<=MaxStepHeight){
                MidClamber=false;
                Vel.xy+=2*ViewVector.XY.Unit();
            }
        }
        if(MidClamber)Vel=(0, 0, (ledgeHeight<=maxStepHeight)?0:1);
    }

    override
    void CheckCrouch(bool totallyfrozen){
        UserCmd cmd=Player.cmd;
        bool CrouchBtn=cmd.buttons & BT_CROUCH;

        if(CanCrouch() && Player.Health>0 && level.IsCrouchingAllowed())
            if(!TotallyFrozen){
                int CrouchDir=Player.Crouching;

                if(CrouchDir==0)CrouchDir=CrouchBtn?-1:1;
                else if(CrouchBtn)Player.Crouching=0;

                if(CrouchDir==1 && Player.CrouchFactor<1 && Pos.Z+Height<ceilingz)CrouchMove(1);
                else if(CrouchDir==-1 && Player.CrouchFactor>0.5)CrouchMove(-1);
            }
        else Player.Uncrouch();
        Player.CrouchOffset=-ViewHeight*(1-Player.CrouchFactor);
    }

    virtual
    void LowerFriction()
    {Friction=(Player.OnGround && !(Player.cmd.buttons & (BT_FORWARD|BT_BACK|BT_MOVELEFT|BT_MOVERIGHT)))?.75:1;}

    virtual
    void CheckCollisionEffects(){
        int Dam;
        if((Dam=LastVel.Length()-Vel.Length())>20)
            if(bSkullfly)Vel.XY=-50*ViewVector.XY.Unit();
            else DamageMobj(self, self, Dam-20, 'Collision', DMG_THRUSTLESS);
        LastVel=Vel;
    }
}